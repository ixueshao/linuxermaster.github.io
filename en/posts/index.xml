<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" 
  xmlns:content="http://purl.org/rss/1.0/modules/content/" 
  xmlns:dc="http://purl.org/dc/elements/1.1/" 
  xmlns:atom="http://www.w3.org/2005/Atom" 
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" 
  xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>Posts on CloudNativeEcosystem</title>
    <link>https://devopsman.cn/en/posts/</link>
    <description>Recent content in Posts on CloudNativeEcosystem</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <managingEditor>marionxue@qq.com (Marionxue)</managingEditor>
    <webMaster>marionxue@qq.com (Marionxue)</webMaster>
    <copyright>[云原生生态圈](https://www.devopsman.cn) &amp;copy;2016-{year}, All Rights Reserved [自由转载-非商用-非衍生-保持署名](https://www.devopsman.cn)</copyright>
    <lastBuildDate>Tue, 07 Jul 2020 12:00:06 +0900</lastBuildDate>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    
        <atom:link href="https://devopsman.cn/en/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    

      
      <item>
        <title>Harbor2.0 安装部署实践(HTTPS)</title>
        <link>https://devopsman.cn/en/posts/20200707-harbor2.0%E5%B8%A6https%E7%9A%84%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5/</link>
        <pubDate>Tue, 07 Jul 2020 12:00:06 +0900</pubDate>
        <author>marionxue@qq.com (Marionxue)</author>
        <atom:modified>Tue, 07 Jul 2020 12:00:06 +0900</atom:modified>
        <guid>https://devopsman.cn/en/posts/20200707-harbor2.0%E5%B8%A6https%E7%9A%84%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5/</guid>
        <description>Harbor是一个开源的管理 Docker 镜像以及 helm 图表的项目，该项目包括了权限管理、LDAP 认证集成、日志事件审计、管理界面 portal、多 Harbor 实例之间数据同步的公布功能，</description>
        <content:encoded>&lt;p&gt;&lt;a href=&#34;https://goharbor.io/&#34; title=&#34;Harbor&#34;&gt;Harbor&lt;/a&gt;是一个开源的管理 Docker 镜像以及 helm 图表的项目，该项目包括了权限管理、LDAP 认证集成、日志事件审计、管理界面 portal、多 Harbor 实例之间数据同步的公布功能，同时今年 Harbor 也从 CNCF 中毕业了，提供了更合规、性能更好、操作体验更佳的 2.0 版本，帮助您在跨 kubernetes 和 Docker 等云原生计算平台持续高效的管理制品。&lt;/p&gt;
&lt;h4 id=&#34;harbor-环境需求&#34;&gt;Harbor 环境需求&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Software&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Version&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Docker engine&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;17.06.0-ce 及以上&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;安装参考: &lt;a href=&#34;https://docs.docker.com/engine/installation/&#34; title=&#34;Docker Engine documentation&#34;&gt;Docker Docs&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Docker Compose&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1.18.0 版本及以上即可&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;安装参考: &lt;a href=&#34;https://docs.docker.com/compose/install/&#34; title=&#34;Docker Compose documentation&#34;&gt;Docker-Compose Docs&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Openssl&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;为避免安全漏洞，建议升级到最新&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可以选择自签证书: &lt;a href=&#34;https://goharbor.io/docs/2.0.0/install-config/configure-https/&#34; title=&#34;Configure HTTPS Access to Harbor&#34;&gt;Config HTTPS&lt;/a&gt;也可以申请个人免费版证书&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;harbor-离线安装&#34;&gt;Harbor 离线安装&lt;/h4&gt;
&lt;p&gt;考虑到网络和测试的需求，我们通过迅雷在 GITHUB 上下载离线安装的 harbor 安装包，其中包含了 Harbor 所需要的基础镜像，离线安装时通过离线安装包内的脚本将导出的镜像文件通过&lt;code&gt;docker load -i&lt;/code&gt;导入到服务器内，然后通过编排软件&lt;code&gt;docker-compose&lt;/code&gt;运行，相当方便。使用到的基础镜像如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;goharbor/chartmuseum-photon          v2.0.0              4db8d6aa63e9        &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; weeks ago         127MB
goharbor/redis-photon                v2.0.0              c89ea2e53cc0        &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; weeks ago         72.2MB
goharbor/trivy-adapter-photon        v2.0.0              6122c52b7e48        &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; weeks ago         103MB
goharbor/clair-adapter-photon        v2.0.0              dd2210cb7f53        &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; weeks ago         62MB
goharbor/clair-photon        &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;        v2.0.0              f7c7fcc52278        &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; weeks ago         171MB
goharbor/notary-server-photon        v2.0.0              983ac10ed8be        &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; weeks ago         143MB
goharbor/notary-signer-photon        v2.0.0              bee1b6d75e0d        &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; weeks ago         140MB
goharbor/harbor-registryctl          v2.0.0              c53c32d58d04        &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; weeks ago         102MB
goharbor/registry-photon             v2.0.0              afdc1b7ada36        &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; weeks ago         84.5MB
goharbor/nginx-photon                v2.0.0              17892f03e56c        &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; weeks ago         43.6MB
goharbor/harbor-log                  v2.0.0              5f8ff08e795c        &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; weeks ago         82MB
goharbor/harbor-jobservice           v2.0.0              c68a2495bf55        &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; weeks ago         116MB
goharbor/harbor-core                 v2.0.0              3aa3af64baf8        &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; weeks ago         138MB
goharbor/harbor-portal               v2.0.0              e0b1d3c894c4        &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; weeks ago         52.4MB
goharbor/harbor-db                   v2.0.0              5c76f0296cec        &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; weeks ago         154MB
goharbor/prepare                     v2.0.0              7266d49995ed        &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; weeks ago         158MB
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在安装之前，我们需要修改一下 Harbor 的配置文件，比如修改 harbor 使用的域名、HTTPS 证书的位置等,下面我们简单的说明:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;☸️  k8sdev🔥 default  ~/Downloads  🐳 👉 scp harbor-offline-installer-v2.0.0.tgz root@192.168.99.128:/root/
&lt;span class=&#34;c1&#34;&gt;# 在192.168.99.128上进行Harbor的安装配置&lt;/span&gt;
root@master:~# tar xf harbor-offline-installer-v2.0.0.tgz
root@master:~/harbor# mv harbor.yml.tmpl harbor.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我们重新命名配置文件 harbor.yml 后，编辑该文件&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;hostname: harbor.devopsman.cn &lt;span class=&#34;c1&#34;&gt;# 配置自己的harbor访问域名&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果你需要配置 HTTPS 来访问 harbor,那么需要申请证书或者自己生成的自签证书，这里我们直接在 DNSPOD 上申请一个免费的一年可用的证书&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images.assets/image-20200707133220228.png&#34; alt=&#34;image-20200707133220228&#34; /&gt;&lt;/p&gt;
&lt;p&gt;实际上 https 的证书是配置给 harbor 的反向代理 nginx 的，我们一般访问 harbor 其实是访问 nginx 然后将请求转发给 harbor，在我们安装完成 harbor 之后，可以运行以下命令查看到 Nginx 相关的反向代理的配置:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;root@master:~/harbor# docker &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; -it nginx cat /etc/nginx/nginx.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;接下来，我们需要配置一下 HTTPS 可信证书，首先在 DNSPOD 上下载申请审批成功后的证书&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images.assets/image-20200707133835126.png&#34; alt=&#34;image-20200707133835126&#34; /&gt;&lt;/p&gt;
&lt;p&gt;然后解压，将解压后的 Nginx 目录下的两个文件重命名放在/data/cert/目录下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;root@master:~/harbor/Nginx# ls -alh
total 32K
drwxr-xr-x   &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; root root 4.0K Jul  &lt;span class=&#34;m&#34;&gt;7&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;2020&lt;/span&gt; .
drwxr-xr-x &lt;span class=&#34;m&#34;&gt;100&lt;/span&gt; root root  20K Jul  &lt;span class=&#34;m&#34;&gt;7&lt;/span&gt; 01:37 ..
-rw-r--r--   &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; root root 3.7K Jul  &lt;span class=&#34;m&#34;&gt;7&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;2020&lt;/span&gt; 1_harbor.devopsman.cn_bundle.crt
-rw-r--r--   &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; root root 1.7K Jul  &lt;span class=&#34;m&#34;&gt;7&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;2020&lt;/span&gt; 2_harbor.devopsman.cn.key
&lt;span class=&#34;c1&#34;&gt;# 重命名之后放在/data/cert目录下，如果没有这个目录，需要提前创建&lt;/span&gt;
mkdir -pv /data/cert
root@master:~/harbor/Nginx# cp 1_harbor.devopsman.cn_bundle.crt /data/cert/harbor.devopsman.cn.crt
root@master:~/harbor/Nginx# cp 2_harbor.devopsman.cn.key /data/cert/harbor.devopsman.cn.key
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后在 harbor.yml 下配置证书的位置即可:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# https related config&lt;/span&gt;
https:
  &lt;span class=&#34;c1&#34;&gt;# https port for harbor, default is 443&lt;/span&gt;
  port: &lt;span class=&#34;m&#34;&gt;443&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;# The path of cert and key files for nginx&lt;/span&gt;
  certificate: /data/cert/harbor.devopsman.cn.crt
  private_key: /data/cert/harbor.devopsman.cn.key
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;配置完证书，使用 prepare 进行配置 nginx 的 https 证书&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; /root/harbor &lt;span class=&#34;c1&#34;&gt;# harbor离线版解压后的文件目录&lt;/span&gt;
root@master:~/harbor# ./prepare
prepare base dir is &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; to /root/harbor
...
Generated configuration file: /compose_location/docker-compose.yml
Clean up the input dir
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;无果没有报错，然后我们就可以直接使用 docker-compose 运行 harbor 的容器了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;root@master:~/harbor# docker-compose up -d
Creating network &lt;span class=&#34;s2&#34;&gt;&amp;#34;harbor_harbor&amp;#34;&lt;/span&gt; with the default driver
Creating harbor-log ... &lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
Creating harbor-portal ... &lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
Creating registry      ... &lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
Creating registryctl   ... &lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
Creating harbor-db     ... &lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
Creating redis         ... &lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
Creating harbor-core   ... &lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
Creating nginx             ... &lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
Creating harbor-jobservice ... &lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;安装检测&#34;&gt;安装检测&lt;/h2&gt;
&lt;p&gt;然后我们可以直接通过 docker login 测试一下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;root@master:~/harbor# docker login harbor.devopsman.cn
Username: admin
Password:                  &lt;span class=&#34;c1&#34;&gt;# 默认的密码在harbor.yml文件中，可以自行修改&lt;/span&gt;
WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;通过浏览器查看是否能登录以及证书的有效期&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images.assets/image-20200707140232427.png&#34; alt=&#34;image-20200707140232427&#34; /&gt;&lt;/p&gt;
&lt;p&gt;此时我们可以通过推送一个测试的镜像，检查是够正常，我们先在浏览器中访问 harbor.devopsman.cn，然后找到推送命令，查看推送的格式，下面我们测试一下看看结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images.assets/image-20200707134847120.png&#34; alt=&#34;image-20200707134847120&#34; /&gt;&lt;/p&gt;
&lt;p&gt;我们选择一个 k8s 集群服务基础组件&lt;code&gt;kube-proxy&lt;/code&gt;的镜像，重新打个镜像的 tag，然后推送到我们的&lt;code&gt;devopsman&lt;/code&gt;仓库内:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;root@master:~/harbor# docker tag k8s.gcr.io/kube-proxy:v1.18.0 harbor.devopsman.cn/devopsman/kube-proxy:v1.18.0
root@master:~/harbor# docker push harbor.devopsman.cn/devopsman/kube-proxy:v1.18.0
The push refers to repository &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;harbor.devopsman.cn/devopsman/kube-proxy&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
46b37415a80a: Pushed
0d8d54147a3a: Pushed
597151d24476: Pushed
ad9fb2411669: Pushed
2dc2f2423ad1: Pushed
682fbb19de80: Pushed
fc4976bd934b: Pushed
v1.18.0: digest: sha256:b832454a96a848ad5c51ad8a499ef2173b627ded2c225e3a6be5aad9446cb211 size: &lt;span class=&#34;m&#34;&gt;1786&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;通过查看，确实成功的完成了镜像的上传:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images.assets/image-20200707135312426.png&#34; alt=&#34;image-20200707135312426&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这样就完成了 harbor 环境的基础搭建，接下来就好好的体验 Harbor 带来的新功能吧，通过图上看到 harbor2.0 目前支持&lt;code&gt;Dark&lt;/code&gt;主题，helm 推送等，开始动手吧，体验 Harbor 的新功能和特性，本章节就完成了 harbor 的基础探索。&lt;/p&gt;
</content:encoded>
        <dc:creator>云原生生态圈</dc:creator>
        <media:content url="https://devopsman.cnimages/posts/harbor-syncdata.jpg" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
        
          
            
              <category>Harbor</category>
            
          
            
              <category>镜像仓库</category>
            
          
            
              <category>HTTPS</category>
            
          
            
              <category>高可用</category>
            
          
        
        
        
      </item>
      
      <item>
        <title>Harbor2.0 多实例之间镜像复制</title>
        <link>https://devopsman.cn/en/posts/20200708-harbor2.0-%E5%A4%9A%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E9%95%9C%E5%83%8F%E5%A4%8D%E5%88%B6/</link>
        <pubDate>Mon, 16 Dec 2019 12:00:06 +0900</pubDate>
        <author>marionxue@qq.com (Marionxue)</author>
        <atom:modified>Mon, 16 Dec 2019 12:00:06 +0900</atom:modified>
        <guid>https://devopsman.cn/en/posts/20200708-harbor2.0-%E5%A4%9A%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E9%95%9C%E5%83%8F%E5%A4%8D%E5%88%B6/</guid>
        <description>&lt;p&gt;harbor 提供了 harbor 与非 harbor 服务之间的镜像复制功能，通过复制镜像功能可以将 DockerHub 上的私有镜像给批量的同步到本地，也可以通过在多 Harbor 实例之间进行同步，达到镜像多副本，数据高可用的作用。&lt;/p&gt;</description>
        <content:encoded>&lt;p&gt;harbor 提供了 harbor 与非 harbor 服务之间的镜像复制功能，通过复制镜像功能可以将 DockerHub 上的私有镜像给批量的同步到本地，也可以通过在多 Harbor 实例之间进行同步，达到镜像多副本，数据高可用的作用。&lt;/p&gt;
&lt;h2 id=&#34;replication-adapters&#34;&gt;Replication Adapters&lt;/h2&gt;
&lt;p&gt;harbor 提供了 harbor 与非 harbor 服务之间的镜像复制功能，通过复制镜像功能可以将 DockerHub 上的私有镜像给批量的同步到本地，也可以通过在多 Harbor 实例之间进行同步，达到镜像多副本，数据高可用的作用。如下图所示，Harbor 支持与 harbor、query.io、Docker-hub 等知名的镜像仓库之间同步，还支持 helm-hub 等 helm 图表之间的同步：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images.assets/image-20200707214455744.png&#34; alt=&#34;image-20200707214455744&#34; style=&#34;zoom: 50%;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;下面我们通过 harbor 与 harbor 实例之间同步，看一下 Harbor 的镜像复制功能&lt;/p&gt;
&lt;h2 id=&#34;harbor-to-harbor&#34;&gt;Harbor To Harbor&lt;/h2&gt;
&lt;p&gt;基于上节&lt;a href=&#34;https://mp.weixin.qq.com/s/ZVsx8sCpCtCE1Qj39NzH7w&#34;&gt;Harbor 开源镜像仓库企业级实践&lt;/a&gt;，安装了域名为&lt;code&gt;harbor.devopsman.cn&lt;/code&gt;的 harbor 实例，根据同样的方式安装一个新的实例，并且配置它的域名为&lt;code&gt;harbor.kubemaster.top&lt;/code&gt;，我们把上一节中推送到 harbor.devopsman.cn 的镜像 devopsman/kube-proxy:v1.18.0 镜像同步到 harbor.kubemaster.top，在准备好这些环境之后，我们开始配置镜像之间的同步。&lt;/p&gt;
&lt;p&gt;首先在 harbor.kubemaster.top 中新增一个仓库目标，如下图所示，配置好目前镜像仓库的地址、用户名和密码之后，点击测试保存&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images.assets/image-20200707220812143.png&#34; alt=&#34;image-20200707220812143&#34; /&gt;&lt;/p&gt;
&lt;p&gt;然后 ，在系统管理下面的复制管理处，新增加一个复制策略，如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images.assets/image-20200707221007564.png&#34; alt=&#34;image-20200707221007564&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在源镜像仓库处选择我们之前在仓库管理处配置好的 harbor 实例，然后配置源资源过滤信息，其中的匹配信息如下，其中(Y)表示合法，(N)表示不合法&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Pattern&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;String(Match or not)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;library/*&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;library/hello-world&lt;/code&gt;(Y) &lt;code&gt;library/my/hello-world&lt;/code&gt;(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;library/**&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;library/hello-world&lt;/code&gt;(Y) &lt;code&gt;library/my/hello-world&lt;/code&gt;(Y)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;{library,goharbor}/**&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;library/hello-world&lt;/code&gt;(Y) &lt;code&gt;goharbor/harbor-core&lt;/code&gt;(Y) &lt;code&gt;google/hello-world&lt;/code&gt;(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;1.?&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;1.0&lt;/code&gt;(Y) &lt;code&gt;1.01&lt;/code&gt;(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;然后填写自定义的过滤器规则之后，保存。然后在复制管理功能处，找到并选择刚才新建的复制规则，点击复制：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images.assets/image-20200707221536601.png&#34; alt=&#34;image-20200707221536601&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这样就手动的触发了复制，其状态为&lt;code&gt;InProgress&lt;/code&gt;，我们点击对应的任务 ID，就能看到更多的复制信息，比如成功状态信息，同步的日志信息等&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images.assets/image-20200707221736851.png&#34; alt=&#34;image-20200707221736851&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这样目标私有镜像仓库中的镜像就被同步了过来，同时 harbor 也支持定时任务同步，其根据 cron 的语法规则实现私有镜像仓库之间的镜像的自动同步。&lt;/p&gt;
&lt;h2 id=&#34;harbor-高可用&#34;&gt;Harbor 高可用&lt;/h2&gt;
&lt;p&gt;如果想要保证 harbor 实例数据的高可用，可以通过复制管理的功能在多个 harbor 之间互相配置同步策略，可以基于&lt;code&gt;push mode&lt;/code&gt;实现任意一个实例上面推送了镜像，都会被自动的同步到其他的实例上去，结合 cron 的定时任务基本上就自实现了 harbor 的数据高可用，避免因单实例造成数据无法挽回。&lt;/p&gt;
&lt;h4 id=&#34;精彩文章回顾&#34;&gt;精彩文章回顾&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/ZVsx8sCpCtCE1Qj39NzH7w&#34;&gt;Harbor 开源镜像仓库企业级实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/_eiiCG-jjIuc0JZKWLXd0A&#34;&gt;阿里云出品·Kubernetes 深入浅出实践 v1.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/Barv9VtraIAWrUkHZFVwpg&#34;&gt;微软出品·Kubernetes 最新学习指南 v3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/VSvsLAb-QEZ7_syDPItyLA&#34;&gt;火焰图：全局视野的 Linux 性能剖析 &lt;code&gt;1k+&lt;/code&gt;在读&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/R5JI3vE995_vfxtYkbQYrA&#34;&gt;最流行的五款 Kubernetes 交互式可视化工具 &lt;code&gt;900+&lt;/code&gt;在读&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/3JIPe9pIbxdN7tGmLtX5ng&#34;&gt;轻松爬取拉勾网岗位招聘信息 &lt;code&gt;600+&lt;/code&gt;在读&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/eycZx7JtLGXy0mkZ1_V2nQ&#34;&gt;Yearning - 最 Popular 的 MYSQL 审计平台 &lt;code&gt;700+&lt;/code&gt;在读&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/TZzsHM1YbUHot6BGRqSzlg&#34;&gt;Prometheus 监控系列-部署篇 &lt;code&gt;500+&lt;/code&gt;在读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
        <dc:creator>云原生生态圈</dc:creator>
        <media:content url="https://devopsman.cnimages/posts/harbor-syncdata.jpg" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
        
          
            
              <category>Harbor</category>
            
          
            
              <category>镜像仓库</category>
            
          
            
              <category>Docker</category>
            
          
            
              <category>高可用</category>
            
          
        
        
        
      </item>
      
      <item>
        <title>🔥图全局视野的Linux性能剖析</title>
        <link>https://devopsman.cn/en/posts/20200704-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9Acpu%E6%B6%88%E8%80%97%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8A/</link>
        <pubDate>Mon, 16 Dec 2019 12:00:06 +0900</pubDate>
        <author>marionxue@qq.com (Marionxue)</author>
        <atom:modified>Mon, 16 Dec 2019 12:00:06 +0900</atom:modified>
        <guid>https://devopsman.cn/en/posts/20200704-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9Acpu%E6%B6%88%E8%80%97%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8A/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://devopsman.cn/static/images/posts/image-20200704183558634.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
        <content:encoded>&lt;p&gt;&lt;img src=&#34;https://devopsman.cn/static/images/posts/image-20200704183558634.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;文章背景&#34;&gt;文章背景&lt;/h2&gt;
&lt;p&gt;日常的工作中，会收到一堆CPU使用率过高的告警邮件，遇到某台服务的&lt;code&gt;CPU被占满了&lt;/code&gt;，这时候我们就要去查看是什么进程将服务器的CPU资源占用满了。通常我们会通过&lt;code&gt;top&lt;/code&gt;或者&lt;code&gt;htop&lt;/code&gt;来快速的查看占据CPU最高的那个进程，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../static/posts/posts/image-20200704183558634.png&#34; alt=&#34;image-20200704183558634&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里是通过一个普通的服务器做演示使用，如图所示当前服务器占用CPU最高的是一个叫做&lt;code&gt;kube-apiserver&lt;/code&gt;命令运行的一个进程，该进程的PID为&lt;code&gt;25633&lt;/code&gt;,当然你可能遇到一个服务器上运行有多个服务，想快速知道占用率最高的那几个进程的话，你可以使用以下命令:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ps aux&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;head -1&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;ps -aux &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sort -k3nr &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; head -n &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; //查看前10个最占用CPU的进程
ps aux&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;head -1&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;ps -aux &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sort -k4nr &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; head -n &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; //查看前10个最占用内存的进程
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;但是通过以上的方法获取到服务器占用资源的进程之后，还是&lt;code&gt;不知道CPU使用究竟耗时在哪里&lt;/code&gt;,不清楚瓶颈在哪里，此时就可以通过&lt;code&gt;Linux&lt;/code&gt;系统的性能分析工具&lt;code&gt;perf&lt;/code&gt;分析，分析其返回的正在消耗CPU的函数以及调用栈。然后可以通过解析&lt;code&gt;perf&lt;/code&gt;采集的数据，渲染到火焰图🔥，就清楚的知道究竟占用系统CPU资源的罪魁祸首了。&lt;/p&gt;
&lt;p&gt;在制作火焰图之前，需要先来说说这个Linux性能分析工具&lt;code&gt;perf&lt;/code&gt;,该工具是一个相对简单易上手的性能分析工具，是&lt;code&gt;Performance&lt;/code&gt;单词的缩写，通过其&lt;code&gt;perf&lt;/code&gt;的命令选项完成系统事件的采集到解析，我们来简单的认识一下：&lt;/p&gt;
&lt;h2 id=&#34;linux上的性能分析工具perf&#34;&gt;linux上的性能分析工具&lt;code&gt;Perf&lt;/code&gt;&lt;/h2&gt;
&lt;h3 id=&#34;安装perf&#34;&gt;安装&lt;code&gt;perf&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;我目前的服务器发行版是&lt;code&gt;Ubuntu 16.04.6 LTS&lt;/code&gt;因此需要先安装perf才能使用，该工具由&lt;code&gt;linux-tools-common&lt;/code&gt;提供，但是它需要安装后面的依赖。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#安装&lt;/span&gt;
root@master:~# apt install linux-tools-common linux-tools-4.4.0-142-generic linux-cloud-tools-4.4.0-142-generic -y

root@master:~# perf -v &lt;span class=&#34;c1&#34;&gt;#显示perf的版本&lt;/span&gt;
perf version 4.4.167
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在安装完成时候，我们就可以对上图CPU使用率最高的进程ID为&lt;code&gt;25633&lt;/code&gt;的进程进行采样分析。&lt;/p&gt;
&lt;p&gt;首选我们采集一下该进程的&lt;code&gt;调用栈&lt;/code&gt;信息:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;root@master:~# sudo perf record -F &lt;span class=&#34;m&#34;&gt;99&lt;/span&gt; -p &lt;span class=&#34;m&#34;&gt;25633&lt;/span&gt; -g -- sleep &lt;span class=&#34;m&#34;&gt;30&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt; perf record: Woken up &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; to write data &lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt; perf record: Captured and wrote 0.039 MB perf.data &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;120&lt;/span&gt; samples&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这个命令会产生一个大的数据文件，取决与你采集的进程与CPU的配置，如果一台服务器有16个 CPU，每秒抽样99次，持续30秒，就得到 47,520 个调用栈，长达几十万甚至上百万行。上面的命令中，&lt;code&gt;perf record&lt;/code&gt;表示记录，&lt;code&gt;-F 99&lt;/code&gt;表示每秒99次，&lt;code&gt;-p 25633&lt;/code&gt;是进程号，即对哪个进程进行分析，&lt;code&gt;-g&lt;/code&gt;表示记录调用栈，&lt;code&gt;sleep 30&lt;/code&gt;则是持续30秒，参数信息可以视情况调整。生成的数据采集文件在当前目录下，名称为&lt;code&gt;perf.data&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;perf record&lt;/code&gt;命令可以从高到低排列统计每个调用栈出现的百分比，显示结果如下图所示:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;root@master:~# sudo perf report -n --stdio
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;images.assets/image-20200704190236668.png&#34; alt=&#34;image-20200704190236668&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这样的效果对使用者来说还是不那么直观易读，这时候，火焰🔥图也就真正的派上用途了。&lt;/p&gt;
&lt;h2 id=&#34;制作火焰图&#34;&gt;制作火焰🔥图&lt;/h2&gt;
&lt;p&gt;火焰🔥图并非一定就是火焰系列的颜色主题，只是通过🔥色系更能表达出含义。火焰图常见的类型有 &lt;a href=&#34;http://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html&#34; title=&#34;On-CPU&#34;&gt;On-CPU&lt;/a&gt;, &lt;a href=&#34;http://www.brendangregg.com/FlameGraphs/offcpuflamegraphs.html&#34; title=&#34;Off-CPU&#34;&gt;Off-CPU&lt;/a&gt;, 还有 &lt;a href=&#34;http://www.brendangregg.com/FlameGraphs/memoryflamegraphs.html&#34; title=&#34;Memory&#34;&gt;Memory&lt;/a&gt;, &lt;a href=&#34;http://www.brendangregg.com/FlameGraphs/hotcoldflamegraphs.html&#34; title=&#34;Hot/Cold&#34;&gt;Hot/Cold&lt;/a&gt;, [&lt;code&gt;Differential](http://www.brendangregg.com/blog/2014-11-09/differential-flame-graphs.html &amp;quot;Differential&amp;quot;) 等等. &lt;/code&gt;on-CPU/off-cpu`的区别就是一个是用于CPU是性能瓶颈，一个是IO是性能瓶颈，当你不知道当前的服务器的性能瓶颈究竟是什么的时候，你可以使用这两种类型进行对比，通过两种火焰图的差别是比较大的，如果两张火焰图长得差不多, 那么通常认为CPU被其它进程抢占了.&lt;/p&gt;
&lt;p&gt;另外一种情况就是如果无法确定当前的系统瓶颈, 可以通过压测工具来确认 : 通过压测工具看看能否让CPU使用率趋于饱和, 如果能那么使用 &lt;code&gt;On-CPU&lt;/code&gt; 火焰图, 如果不管怎么压, CPU 使用率始终上不来, 那么多半说明程序被 &lt;code&gt;IO&lt;/code&gt; 或锁卡住了, 此时适合使用 &lt;code&gt;Off-CPU&lt;/code&gt; 火焰图. 你可以通过压测工具进行测试，目前比较常用的就是&lt;code&gt;ab&lt;/code&gt;和&lt;code&gt;wrk&lt;/code&gt;，我建议尝试使用诸如 &lt;a href=&#34;https://github.com/wg/wrk&#34; title=&#34;wrk&#34;&gt;wrk&lt;/a&gt; 之类更现代的压测工具.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果选择 &lt;code&gt;ab&lt;/code&gt; 的话, 那么务必记得开启 &lt;code&gt;-k&lt;/code&gt; 选项, 以避免耗尽系统的可用端口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Github上有&lt;code&gt;Brendan D. Gregg&lt;/code&gt; 的 &lt;code&gt;Flame Graph&lt;/code&gt; 工程实现了一套生成火焰图的脚本.我们可以直接克隆下来直接用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; git clone https://github.com/brendangregg/FlameGraph.git
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;生成火焰🔥图，我们一般都遵循以下流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images.assets/image-20200704192051139.png&#34; alt=&#34;image-20200704192051139&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;捕获堆栈&lt;/code&gt;: 使用&lt;code&gt;perf&lt;/code&gt;捕捉进程运行堆栈信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;折叠堆栈&lt;/code&gt;: 对抓取的系统和程序运行每一时刻的堆栈信息进行分析组合, 将重复的堆栈累计在一起, 从而体现出负载和关键路径，通过&lt;code&gt;stackcollapse&lt;/code&gt;脚本完成&lt;/li&gt;
&lt;li&gt;&lt;code&gt;生成火焰图&lt;/code&gt;：分析 stackcollapse 输出的堆栈信息渲染成火焰图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Flame Graph&lt;/code&gt;中提供了抓取不同信息的脚本，可以按需使用。下面我们需要对捕获到的进程堆栈信息&lt;code&gt;perf.data&lt;/code&gt;进行折叠，生成折叠的堆栈信息:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;root@master:~# perf script -i /root/perf.data &lt;span class=&#34;p&#34;&gt;&amp;amp;&lt;/span&gt;&amp;gt; /root/perf.unfold
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;用 &lt;code&gt;stackcollapse-perf.pl&lt;/code&gt; 将 perf 解析出的内容 &lt;code&gt;perf.unfold&lt;/code&gt; 中的符号进行折叠&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;root@master:~/FlameGraph# ls
aix-perf.pl    docs                        example-perf.svg  pkgsplit-perf.pl  stackcollapse-aix.pl       stackcollapse-go.pl               stackcollapse-ljp.awk         stackcollapse-pmc.pl        stackcollapse-vsprof.pl   test.sh
demos          example-dtrace-stacks.txt   files.pl          range-perf.pl     stackcollapse-bpftrace.pl  stackcollapse-instruments.pl      stackcollapse-perf.pl         stackcollapse-recursive.pl  stackcollapse-vtune.pl
dev            example-dtrace.svg          flamegraph.pl     README.md         stackcollapse-elfutils.pl  stackcollapse-java-exceptions.pl  stackcollapse-perf-sched.awk  stackcollapse-sample.awk    stackcollapse-xdebug.php
difffolded.pl  example-perf-stacks.txt.gz  jmaps             record-test.sh    stackcollapse-gdb.pl       stackcollapse-jstack.pl           stackcollapse.pl              stackcollapse-stap.pl       &lt;span class=&#34;nb&#34;&gt;test&lt;/span&gt;
root@master:~/FlameGraph# ./stackcollapse-perf.pl /root/perf.unfold &lt;span class=&#34;p&#34;&gt;&amp;amp;&lt;/span&gt;&amp;gt; /root/perf.folded
root@master:~/FlameGraph#
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;最后就是生成火焰🔥图了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;root@master:~/FlameGraph# ./flamegraph.pl /root/perf.folded &amp;gt; /root/perf.svg
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当然也可以通过管道符&lt;code&gt;|&lt;/code&gt;将整个过程简化:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; perf script &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; FlameGraph/stackcollapse-perf.pl &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; FlameGraph/flamegraph.pl &amp;gt; process.svg
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;最后在谷歌浏览器上打开该火焰图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images.assets/image-20200704193400492.png&#34; alt=&#34;image-20200704193400492&#34; /&gt;&lt;/p&gt;
&lt;p&gt;火焰图是基于&lt;code&gt;stack&lt;/code&gt;信息生成的&lt;code&gt;SVG&lt;/code&gt; 图片, 用来展示 CPU 的调用栈。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;y&lt;/code&gt; 轴表示调用栈, 每一层都是一个函数. 调用栈越深, 火焰就越高, 顶部就是正在执行的函数, 下方都是它的父函数.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt; 轴表示抽样数, 如果一个函数在 x 轴占据的宽度越宽, 就表示它被抽到的次数多, 即执行的时间长. 注意, x 轴不代表时间, 而是所有的调用栈合并后, 按字母顺序排列的.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;火焰图就是看顶层的哪个函数占据的宽度最大. 只要有&lt;code&gt;&amp;quot;平顶&amp;quot;(plateaus)&lt;/code&gt;, 就表示该函数可能存在性能问题。颜色没有特殊含义, 因为火焰图表示的是 CPU 的繁忙程度, 所以一般选择暖色调.&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;调用栈不完整&lt;/code&gt;调用栈过深时，某些系统只返回前面的一部分（比如前10层）;当&lt;code&gt;函数名缺失&lt;/code&gt;，函数没有名字，编译器只用内存地址来表示（比如匿名函数），所以使用火焰图也是存在分析不到的地方。你也可以通过以下脚本进行采集分析火焰图:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-&gt;:GetherAnalysisData.sh&#34; data-lang=&#34;&gt;:GetherAnalysisData.sh&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$#&lt;/span&gt; -ne &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;then&lt;/span&gt;
	&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Usage: &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$0&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt; seconds&amp;#34;&lt;/span&gt;
	&lt;span class=&#34;nb&#34;&gt;exit&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;fi&lt;/span&gt;
perf record -a -g -o perf.data &lt;span class=&#34;p&#34;&gt;&amp;amp;&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;PID&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;ps aux&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep &lt;span class=&#34;s2&#34;&gt;&amp;#34;perf record&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep -v grep&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; awk &lt;span class=&#34;s1&#34;&gt;&amp;#39;{print $2}&amp;#39;&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt; -n &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$PID&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;then&lt;/span&gt;
	sleep &lt;span class=&#34;nv&#34;&gt;$1&lt;/span&gt;
	&lt;span class=&#34;nb&#34;&gt;kill&lt;/span&gt; -s INT &lt;span class=&#34;nv&#34;&gt;$PID&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;fi&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# wait until perf exite&lt;/span&gt;
sleep &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;

perf script -i perf.data &lt;span class=&#34;p&#34;&gt;&amp;amp;&lt;/span&gt;&amp;gt; perf.unfold
perl stackcollapse-perf.pl perf.unfold &lt;span class=&#34;p&#34;&gt;&amp;amp;&lt;/span&gt;&amp;gt; perf.folded
perl flamegraph.pl perf.folded &amp;gt;perf.svg
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</content:encoded>
        <dc:creator>云原生生态圈</dc:creator>
        <media:content url="https://devopsman.cnimages/feature1/graph.png" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        <media:content url="https://devopsman.cnimages/posts/image-20200704183558634.png" medium="image"><media:title type="html">meta image</media:title></media:content>
        
          
            
              <category>火焰🔥图</category>
            
          
            
              <category>Linux</category>
            
          
            
              <category>性能分析</category>
            
          
        
        
        
      </item>
      

    
  </channel>
</rss>