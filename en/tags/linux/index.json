[{"content":"Harbor是一个开源的管理 Docker 镜像以及 helm 图表的项目，该项目包括了权限管理、LDAP 认证集成、日志事件审计、管理界面 portal、多 Harbor 实例之间数据同步的公布功能，同时今年 Harbor 也从 CNCF 中毕业了，提供了更合规、性能更好、操作体验更佳的 2.0 版本，帮助您在跨 kubernetes 和 Docker 等云原生计算平台持续高效的管理制品。\nHarbor 环境需求    Software Version Description     Docker engine 17.06.0-ce 及以上 安装参考: Docker Docs   Docker Compose 1.18.0 版本及以上即可 安装参考: Docker-Compose Docs   Openssl 为避免安全漏洞，建议升级到最新 可以选择自签证书: Config HTTPS也可以申请个人免费版证书    Harbor 离线安装 考虑到网络和测试的需求，我们通过迅雷在 GITHUB 上下载离线安装的 harbor 安装包，其中包含了 Harbor 所需要的基础镜像，离线安装时通过离线安装包内的脚本将导出的镜像文件通过docker load -i导入到服务器内，然后通过编排软件docker-compose运行，相当方便。使用到的基础镜像如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  goharbor/chartmuseum-photon v2.0.0 4db8d6aa63e9 8 weeks ago 127MB goharbor/redis-photon v2.0.0 c89ea2e53cc0 8 weeks ago 72.2MB goharbor/trivy-adapter-photon v2.0.0 6122c52b7e48 8 weeks ago 103MB goharbor/clair-adapter-photon v2.0.0 dd2210cb7f53 8 weeks ago 62MB goharbor/clair-photon 2 v2.0.0 f7c7fcc52278 8 weeks ago 171MB goharbor/notary-server-photon v2.0.0 983ac10ed8be 8 weeks ago 143MB goharbor/notary-signer-photon v2.0.0 bee1b6d75e0d 8 weeks ago 140MB goharbor/harbor-registryctl v2.0.0 c53c32d58d04 8 weeks ago 102MB goharbor/registry-photon v2.0.0 afdc1b7ada36 8 weeks ago 84.5MB goharbor/nginx-photon v2.0.0 17892f03e56c 8 weeks ago 43.6MB goharbor/harbor-log v2.0.0 5f8ff08e795c 8 weeks ago 82MB goharbor/harbor-jobservice v2.0.0 c68a2495bf55 8 weeks ago 116MB goharbor/harbor-core v2.0.0 3aa3af64baf8 8 weeks ago 138MB goharbor/harbor-portal v2.0.0 e0b1d3c894c4 8 weeks ago 52.4MB goharbor/harbor-db v2.0.0 5c76f0296cec 8 weeks ago 154MB goharbor/prepare v2.0.0 7266d49995ed 8 weeks ago 158MB   在安装之前，我们需要修改一下 Harbor 的配置文件，比如修改 harbor 使用的域名、HTTPS 证书的位置等,下面我们简单的说明:\n1 2 3 4  ☸️ k8sdev🔥 default ~/Downloads  🐳 👉 scp harbor-offline-installer-v2.0.0.tgz root@192.168.99.128:/root/ # 在192.168.99.128上进行Harbor的安装配置 root@master:~# tar xf harbor-offline-installer-v2.0.0.tgz root@master:~/harbor# mv harbor.yml.tmpl harbor.yml   我们重新命名配置文件 harbor.yml 后，编辑该文件\n1  hostname: harbor.devopsman.cn # 配置自己的harbor访问域名   如果你需要配置 HTTPS 来访问 harbor,那么需要申请证书或者自己生成的自签证书，这里我们直接在 DNSPOD 上申请一个免费的一年可用的证书\n实际上 https 的证书是配置给 harbor 的反向代理 nginx 的，我们一般访问 harbor 其实是访问 nginx 然后将请求转发给 harbor，在我们安装完成 harbor 之后，可以运行以下命令查看到 Nginx 相关的反向代理的配置:\n1  root@master:~/harbor# docker exec -it nginx cat /etc/nginx/nginx.conf   接下来，我们需要配置一下 HTTPS 可信证书，首先在 DNSPOD 上下载申请审批成功后的证书\n然后解压，将解压后的 Nginx 目录下的两个文件重命名放在/data/cert/目录下\n1 2 3 4 5 6 7 8 9 10  root@master:~/harbor/Nginx# ls -alh total 32K drwxr-xr-x 2 root root 4.0K Jul 7 2020 . drwxr-xr-x 100 root root 20K Jul 7 01:37 .. -rw-r--r-- 1 root root 3.7K Jul 7 2020 1_harbor.devopsman.cn_bundle.crt -rw-r--r-- 1 root root 1.7K Jul 7 2020 2_harbor.devopsman.cn.key # 重命名之后放在/data/cert目录下，如果没有这个目录，需要提前创建 mkdir -pv /data/cert root@master:~/harbor/Nginx# cp 1_harbor.devopsman.cn_bundle.crt /data/cert/harbor.devopsman.cn.crt root@master:~/harbor/Nginx# cp 2_harbor.devopsman.cn.key /data/cert/harbor.devopsman.cn.key   然后在 harbor.yml 下配置证书的位置即可:\n1 2 3 4 5 6 7  # https related config https: # https port for harbor, default is 443 port: 443 # The path of cert and key files for nginx certificate: /data/cert/harbor.devopsman.cn.crt private_key: /data/cert/harbor.devopsman.cn.key   配置完证书，使用 prepare 进行配置 nginx 的 https 证书\n1 2 3 4 5 6  cd /root/harbor # harbor离线版解压后的文件目录 root@master:~/harbor# ./prepare prepare base dir is set to /root/harbor ... Generated configuration file: /compose_location/docker-compose.yml Clean up the input dir   无果没有报错，然后我们就可以直接使用 docker-compose 运行 harbor 的容器了\n1 2 3 4 5 6 7 8 9 10 11  root@master:~/harbor# docker-compose up -d Creating network \u0026#34;harbor_harbor\u0026#34; with the default driver Creating harbor-log ... done Creating harbor-portal ... done Creating registry ... done Creating registryctl ... done Creating harbor-db ... done Creating redis ... done Creating harbor-core ... done Creating nginx ... done Creating harbor-jobservice ... done   安装检测 然后我们可以直接通过 docker login 测试一下\n1 2 3 4 5 6 7 8  root@master:~/harbor# docker login harbor.devopsman.cn Username: admin Password: # 默认的密码在harbor.yml文件中，可以自行修改 WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded   通过浏览器查看是否能登录以及证书的有效期\n此时我们可以通过推送一个测试的镜像，检查是够正常，我们先在浏览器中访问 harbor.devopsman.cn，然后找到推送命令，查看推送的格式，下面我们测试一下看看结果：\n我们选择一个 k8s 集群服务基础组件kube-proxy的镜像，重新打个镜像的 tag，然后推送到我们的devopsman仓库内:\n1 2 3 4 5 6 7 8 9 10 11  root@master:~/harbor# docker tag k8s.gcr.io/kube-proxy:v1.18.0 harbor.devopsman.cn/devopsman/kube-proxy:v1.18.0 root@master:~/harbor# docker push harbor.devopsman.cn/devopsman/kube-proxy:v1.18.0 The push refers to repository [harbor.devopsman.cn/devopsman/kube-proxy] 46b37415a80a: Pushed 0d8d54147a3a: Pushed 597151d24476: Pushed ad9fb2411669: Pushed 2dc2f2423ad1: Pushed 682fbb19de80: Pushed fc4976bd934b: Pushed v1.18.0: digest: sha256:b832454a96a848ad5c51ad8a499ef2173b627ded2c225e3a6be5aad9446cb211 size: 1786   通过查看，确实成功的完成了镜像的上传:\n这样就完成了 harbor 环境的基础搭建，接下来就好好的体验 Harbor 带来的新功能吧，通过图上看到 harbor2.0 目前支持Dark主题，helm 推送等，开始动手吧，体验 Harbor 的新功能和特性，本章节就完成了 harbor 的基础探索。\n","description":"Harbor是一个开源的管理 Docker 镜像以及 Helm 图表的项目","id":2,"section":"posts","tags":["Harbor","镜像仓库","HTTPS","高可用"],"title":"Harbor2.0 安装部署实践(HTTPS)","uri":"https://linuxermaster.github.io/en/posts/20200707-harbor2.0%E5%B8%A6https%E7%9A%84%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5/"},{"content":"harbor 提供了 harbor 与非 harbor 服务之间的镜像复制功能，通过复制镜像功能可以将 DockerHub 上的私有镜像给批量的同步到本地，也可以通过在多 Harbor 实例之间进行同步，达到镜像多副本，数据高可用的作用。\nReplication Adapters harbor 提供了 harbor 与非 harbor 服务之间的镜像复制功能，通过复制镜像功能可以将 DockerHub 上的私有镜像给批量的同步到本地，也可以通过在多 Harbor 实例之间进行同步，达到镜像多副本，数据高可用的作用。如下图所示，Harbor 支持与 harbor、query.io、Docker-hub 等知名的镜像仓库之间同步，还支持 helm-hub 等 helm 图表之间的同步：\n下面我们通过 harbor 与 harbor 实例之间同步，看一下 Harbor 的镜像复制功能\nHarbor To Harbor 基于上节Harbor 开源镜像仓库企业级实践，安装了域名为harbor.devopsman.cn的 harbor 实例，根据同样的方式安装一个新的实例，并且配置它的域名为harbor.kubemaster.top，我们把上一节中推送到 harbor.devopsman.cn 的镜像 devopsman/kube-proxy:v1.18.0 镜像同步到 harbor.kubemaster.top，在准备好这些环境之后，我们开始配置镜像之间的同步。\n首先在 harbor.kubemaster.top 中新增一个仓库目标，如下图所示，配置好目前镜像仓库的地址、用户名和密码之后，点击测试保存\n然后 ，在系统管理下面的复制管理处，新增加一个复制策略，如下图:\n在源镜像仓库处选择我们之前在仓库管理处配置好的 harbor 实例，然后配置源资源过滤信息，其中的匹配信息如下，其中(Y)表示合法，(N)表示不合法\n   Pattern String(Match or not)     library/* library/hello-world(Y) library/my/hello-world(N)   library/** library/hello-world(Y) library/my/hello-world(Y)   {library,goharbor}/** library/hello-world(Y) goharbor/harbor-core(Y) google/hello-world(N)   1.? 1.0(Y) 1.01(N)    然后填写自定义的过滤器规则之后，保存。然后在复制管理功能处，找到并选择刚才新建的复制规则，点击复制：\n这样就手动的触发了复制，其状态为InProgress，我们点击对应的任务 ID，就能看到更多的复制信息，比如成功状态信息，同步的日志信息等\n这样目标私有镜像仓库中的镜像就被同步了过来，同时 harbor 也支持定时任务同步，其根据 cron 的语法规则实现私有镜像仓库之间的镜像的自动同步。\nHarbor 高可用 如果想要保证 harbor 实例数据的高可用，可以通过复制管理的功能在多个 harbor 之间互相配置同步策略，可以基于push mode实现任意一个实例上面推送了镜像，都会被自动的同步到其他的实例上去，结合 cron 的定时任务基本上就自实现了 harbor 的数据高可用，避免因单实例造成数据无法挽回。\n精彩文章回顾  Harbor 开源镜像仓库企业级实现 阿里云出品·Kubernetes 深入浅出实践 v1.0 微软出品·Kubernetes 最新学习指南 v3.0 火焰图：全局视野的 Linux 性能剖析 1k+在读 最流行的五款 Kubernetes 交互式可视化工具 900+在读 轻松爬取拉勾网岗位招聘信息 600+在读 Yearning - 最 Popular 的 MYSQL 审计平台 700+在读 Prometheus 监控系列-部署篇 500+在读 ","description":"harbor提供了harbor与非harbor服务之间的镜像复制功能，达到镜像多副本，数据高可用的作用。","id":3,"section":"posts","tags":["Harbor","镜像仓库","Docker","高可用"],"title":"Harbor2.0 多实例之间镜像复制","uri":"https://linuxermaster.github.io/en/posts/20200708-harbor2.0-%E5%A4%9A%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E9%95%9C%E5%83%8F%E5%A4%8D%E5%88%B6/"},{"content":"文章背景 日常的工作中，会收到一堆CPU使用率过高的告警邮件，遇到某台服务的CPU被占满了，这时候我们就要去查看是什么进程将服务器的CPU资源占用满了。通常我们会通过top或者htop来快速的查看占据CPU最高的那个进程，如下图：\n这里是通过一个普通的服务器做演示使用，如图所示当前服务器占用CPU最高的是一个叫做kube-apiserver命令运行的一个进程，该进程的PID为25633,当然你可能遇到一个服务器上运行有多个服务，想快速知道占用率最高的那几个进程的话，你可以使用以下命令:\n1 2  ps aux|head -1;ps -aux | sort -k3nr | head -n 10 //查看前10个最占用CPU的进程 ps aux|head -1;ps -aux | sort -k4nr | head -n 10 //查看前10个最占用内存的进程   但是通过以上的方法获取到服务器占用资源的进程之后，还是不知道CPU使用究竟耗时在哪里,不清楚瓶颈在哪里，此时就可以通过Linux系统的性能分析工具perf分析，分析其返回的正在消耗CPU的函数以及调用栈。然后可以通过解析perf采集的数据，渲染到火焰图🔥，就清楚的知道究竟占用系统CPU资源的罪魁祸首了。\n在制作火焰图之前，需要先来说说这个Linux性能分析工具perf,该工具是一个相对简单易上手的性能分析工具，是Performance单词的缩写，通过其perf的命令选项完成系统事件的采集到解析，我们来简单的认识一下：\nlinux上的性能分析工具Perf 安装perf 我目前的服务器发行版是Ubuntu 16.04.6 LTS因此需要先安装perf才能使用，该工具由linux-tools-common提供，但是它需要安装后面的依赖。\n1 2 3 4 5  #安装 root@master:~# apt install linux-tools-common linux-tools-4.4.0-142-generic linux-cloud-tools-4.4.0-142-generic -y root@master:~# perf -v #显示perf的版本 perf version 4.4.167   在安装完成时候，我们就可以对上图CPU使用率最高的进程ID为25633的进程进行采样分析。\n首选我们采集一下该进程的调用栈信息:\n1 2 3  root@master:~# sudo perf record -F 99 -p 25633 -g -- sleep 30 [ perf record: Woken up 1 times to write data ] [ perf record: Captured and wrote 0.039 MB perf.data (120 samples) ]   这个命令会产生一个大的数据文件，取决与你采集的进程与CPU的配置，如果一台服务器有16个 CPU，每秒抽样99次，持续30秒，就得到 47,520 个调用栈，长达几十万甚至上百万行。上面的命令中，perf record表示记录，-F 99表示每秒99次，-p 25633是进程号，即对哪个进程进行分析，-g表示记录调用栈，sleep 30则是持续30秒，参数信息可以视情况调整。生成的数据采集文件在当前目录下，名称为perf.data。\nperf record命令可以从高到低排列统计每个调用栈出现的百分比，显示结果如下图所示:\n1  root@master:~# sudo perf report -n --stdio   这样的效果对使用者来说还是不那么直观易读，这时候，火焰🔥图也就真正的派上用途了。\n制作火焰🔥图 火焰🔥图并非一定就是火焰系列的颜色主题，只是通过🔥色系更能表达出含义。火焰图常见的类型有 On-CPU, Off-CPU, 还有 Memory, Hot/Cold, [Differential](http://www.brendangregg.com/blog/2014-11-09/differential-flame-graphs.html \u0026quot;Differential\u0026quot;) 等等. on-CPU/off-cpu`的区别就是一个是用于CPU是性能瓶颈，一个是IO是性能瓶颈，当你不知道当前的服务器的性能瓶颈究竟是什么的时候，你可以使用这两种类型进行对比，通过两种火焰图的差别是比较大的，如果两张火焰图长得差不多, 那么通常认为CPU被其它进程抢占了.\n另外一种情况就是如果无法确定当前的系统瓶颈, 可以通过压测工具来确认 : 通过压测工具看看能否让CPU使用率趋于饱和, 如果能那么使用 On-CPU 火焰图, 如果不管怎么压, CPU 使用率始终上不来, 那么多半说明程序被 IO 或锁卡住了, 此时适合使用 Off-CPU 火焰图. 你可以通过压测工具进行测试，目前比较常用的就是ab和wrk，我建议尝试使用诸如 wrk 之类更现代的压测工具.\n 如果选择 ab 的话, 那么务必记得开启 -k 选项, 以避免耗尽系统的可用端口\n Github上有Brendan D. Gregg 的 Flame Graph 工程实现了一套生成火焰图的脚本.我们可以直接克隆下来直接用。\n1  cd \u0026amp;\u0026amp; git clone https://github.com/brendangregg/FlameGraph.git   生成火焰🔥图，我们一般都遵循以下流程\n 捕获堆栈: 使用perf捕捉进程运行堆栈信息 折叠堆栈: 对抓取的系统和程序运行每一时刻的堆栈信息进行分析组合, 将重复的堆栈累计在一起, 从而体现出负载和关键路径，通过stackcollapse脚本完成 生成火焰图：分析 stackcollapse 输出的堆栈信息渲染成火焰图  Flame Graph中提供了抓取不同信息的脚本，可以按需使用。下面我们需要对捕获到的进程堆栈信息perf.data进行折叠，生成折叠的堆栈信息:\n1  root@master:~# perf script -i /root/perf.data \u0026amp;\u0026gt; /root/perf.unfold   用 stackcollapse-perf.pl 将 perf 解析出的内容 perf.unfold 中的符号进行折叠\n1 2 3 4 5 6 7  root@master:~/FlameGraph# ls aix-perf.pl docs example-perf.svg pkgsplit-perf.pl stackcollapse-aix.pl stackcollapse-go.pl stackcollapse-ljp.awk stackcollapse-pmc.pl stackcollapse-vsprof.pl test.sh demos example-dtrace-stacks.txt files.pl range-perf.pl stackcollapse-bpftrace.pl stackcollapse-instruments.pl stackcollapse-perf.pl stackcollapse-recursive.pl stackcollapse-vtune.pl dev example-dtrace.svg flamegraph.pl README.md stackcollapse-elfutils.pl stackcollapse-java-exceptions.pl stackcollapse-perf-sched.awk stackcollapse-sample.awk stackcollapse-xdebug.php difffolded.pl example-perf-stacks.txt.gz jmaps record-test.sh stackcollapse-gdb.pl stackcollapse-jstack.pl stackcollapse.pl stackcollapse-stap.pl test root@master:~/FlameGraph# ./stackcollapse-perf.pl /root/perf.unfold \u0026amp;\u0026gt; /root/perf.folded root@master:~/FlameGraph#   最后就是生成火焰🔥图了\n1  root@master:~/FlameGraph# ./flamegraph.pl /root/perf.folded \u0026gt; /root/perf.svg   当然也可以通过管道符|将整个过程简化:\n1  cd \u0026amp;\u0026amp; perf script | FlameGraph/stackcollapse-perf.pl | FlameGraph/flamegraph.pl \u0026gt; process.svg   最后在谷歌浏览器上打开该火焰图:\n火焰图是基于stack信息生成的SVG 图片, 用来展示 CPU 的调用栈。\n  y 轴表示调用栈, 每一层都是一个函数. 调用栈越深, 火焰就越高, 顶部就是正在执行的函数, 下方都是它的父函数.\n  x 轴表示抽样数, 如果一个函数在 x 轴占据的宽度越宽, 就表示它被抽到的次数多, 即执行的时间长. 注意, x 轴不代表时间, 而是所有的调用栈合并后, 按字母顺序排列的.\n  火焰图就是看顶层的哪个函数占据的宽度最大. 只要有\u0026quot;平顶\u0026quot;(plateaus), 就表示该函数可能存在性能问题。颜色没有特殊含义, 因为火焰图表示的是 CPU 的繁忙程度, 所以一般选择暖色调.\n当调用栈不完整调用栈过深时，某些系统只返回前面的一部分（比如前10层）;当函数名缺失，函数没有名字，编译器只用内存地址来表示（比如匿名函数），所以使用火焰图也是存在分析不到的地方。你也可以通过以下脚本进行采集分析火焰图:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  :GetherAnalysisData.sh\" data-lang=\":GetherAnalysisData.sh\"if [ $# -ne 1 ];then echo \u0026#34;Usage: $0seconds\u0026#34; exit 1 fi perf record -a -g -o perf.data \u0026amp; PID=`ps aux| grep \u0026#34;perf record\u0026#34;| grep -v grep| awk \u0026#39;{print $2}\u0026#39;` if [ -n \u0026#34;$PID\u0026#34; ]; then sleep $1 kill -s INT $PID fi # wait until perf exite sleep 1 perf script -i perf.data \u0026amp;\u0026gt; perf.unfold perl stackcollapse-perf.pl perf.unfold \u0026amp;\u0026gt; perf.folded perl flamegraph.pl perf.folded \u0026gt;perf.svg   ","description":"火焰🔥图并非一定就是火焰系列的颜色主题，只是通过🔥色系更能表达出含义。","id":4,"section":"posts","tags":["火焰🔥图","Linux","性能分析"],"title":"🔥图全局视野的Linux性能剖析","uri":"https://linuxermaster.github.io/en/posts/20200704-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9Acpu%E6%B6%88%E8%80%97%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8A/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":5,"section":"gallery","tags":null,"title":"Cartoon","uri":"https://linuxermaster.github.io/en/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":6,"section":"gallery","tags":null,"title":"Photo","uri":"https://linuxermaster.github.io/en/gallery/photo/"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","description":"Hugo, the world’s fastest framework for building websites","id":11,"section":"","tags":null,"title":"About","uri":"https://linuxermaster.github.io/en/about/"}]